# 内存管理

![image-20200725223500431](页表和虚拟内存.assets/image-20200725223500431.png)

## 页表

## 虚拟内存

### 为什么要有虚拟内存

在早期计算中，是没有虚拟内存的概念的。我们要运行一个程序，会把从程序全部装入内存中，然后运行。当运行多个程序时，经常会出现以下问题。

1. 进程地址空间不隔离，没有权限保护：

   由于程序都是直接访问物理内存，所以一个进程可以修改其他进程的内存数据，设置修改内核地址空间中的数据。

2. 内存使用效率低下

   当内存空间不足时，要将其他程序暂时拷贝到硬盘，然后将新的程序装入内存中运行。由于大量的数据装入装出，内存使用的效率会十分低下

3. 程序运行的地址不确定

   因为内存地址是随机分配的，所以程序运行的地址也是不确定的

### 进程的虚拟地址空间

1. 每个进程都有自己独立的4G内存空间
2. 虚拟内存空间是通过MMU来和真是的物理内存产生联系的

![image-20200725230950617](页表和虚拟内存.assets/image-20200725230950617.png)



### 虚拟内存和物理内存是如何建立起来联系的

#### Linux的虚拟内存技术

Linux把虚拟空间分成若干大小相等的存储分区，Linux把这样的分区叫做页。为了换入换出的方便，物理内存也就按页的大小分成若干个块。由于物理内存中的块空间是用来容纳虚存页的容器，所以物理内存中的块叫做页框。页与页框是Linux实现虚拟内存技术的基础。

<img src="页表和虚拟内存.assets/image-20200725231738984.png" alt="image-20200725231738984" style="zoom:150%;" />

#### 分页和分表

系统里的基本单位都是 Byte 字节，如果将一个虚拟内存的Byte都对应到物理内存的地址，每个条目最少需要 8 字节，在 4G 内存的情况下，就需要32GB 的空间来存放对照表。那么这张表就大的真正的物理地址也放不下了，于是操作系统引入了页的概念。

在系统启动时，操作系统将整个物理内存以 4K 为单位，划分为各个页。之后进行内存分配时，都以页为单位，那么虚拟内存页对应物理内粗你页的映射表就大大减小了，4G内存，只需要8M映射表即可。一些进程没有使用到的虚拟内存，也并不需要保存映射关系，而且Linux还为大内存设计了多级页表，可以进一步减少内存消耗。操作系统虚拟内存到物理内存的映射表，就成为页表。

#### 虚拟内存的页、物理内存的页框以及页表

物理内粗你和虚拟内存被分成了页框与页之后，其存储单元原来的地址都被自然的分成了两段，并且这两段各自代表不同的意义：高位段分表叫做页框码和页码，他们是识别页框和页的编码；低位码分别叫做页框偏移量和页内偏移量，他们是存储单元在页框和页内的地址编码。下图就是两段虚拟内存和物理内存分页之后的情况：

![image-20200725232543837](页表和虚拟内存.assets/image-20200725232543837.png)

为了使系统可以正确的访问虚存页在对应页框中的映像，在把一个页映射到某个页框的同时，就必须把页码和存放该页映像的页框码填入一个较坐页表的表项中。这个页表就是之前提到的映射记录表。

![image-20200725232816689](页表和虚拟内存.assets/image-20200725232816689.png)

页模式下，虚拟地址、物理地址转换关系的示意图

![image-20200725233028804](页表和虚拟内存.assets/image-20200725233028804.png)

也就是说：处理器遇到的地址都是虚拟地址。虚拟地址和物理地址都分成页码（页框码）和偏移值两部分。在由虚拟地址 转化成物理地址的过程中，偏移值不变。而页码和页框码之间的映射就在一个映射记录表——页表中。

#### 页表共享

再多程序系统中，常常有多个程序需要共享同一段代码或数据的情况。在分页管理的存储器中，让多个程序共享同一个页面即可。

具体的方法是：使这些相关程序的虚拟空间的页面在页表中指向内存中的同一个页框。这样，当程序运行并访问这些相关页面时，就都是对同一个页框中的页面进行访问，而该页框中的页就是就被这些程序所共享。

![image-20200725233626953](页表和虚拟内存.assets/image-20200725233626953.png)

### 虚拟内存的好处

#### 进程内存管理

有助于进程进行内存管理。

内存完整性：由于虚拟内存对进程的欺骗，每个进程都认为自己获取的内存是一块连续的地址。我们在编写应用程序时，就不用考虑大块地址的分配，总是认为系统有足够大块的内存。

安全：由于进程访问内存时，都需要通过页表进行寻址，操作系统在页表的各个项目上添加各种访问权限标识符，就可以实现内存的权限控制

#### 数据共享

通过虚拟内存更容易实现内存和数据的共享。

在进程加载系统库时，总实先分配一块内存，将磁盘中的库文件加载到这块内存中，再直接使用物理内存时，由于物理内存地址唯一，计是系统发现同一个库在系统内加载了两次，但每个进程指定的加载内存不一样，系统也无能为力。

而在使用虚拟内存时，系统只需要将进程的虚拟地址指向文件所在的物理内存地址即可。

而通过使用虚拟内存使用共享内存也很简单，系统只需要将各个进程的虚拟内存地址指向系统分配的共享内存地址即可。

#### SWAP

一个应用是被逐段运行的。

![image-20200725234401987](页表和虚拟内存.assets/image-20200725234401987.png)