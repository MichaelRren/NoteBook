# 一些 Object 类中的方法说明

## `equals()`方法
### 特点
* 自反性、传递性、对称性、一致性(第一次调用为True，那么第 n 次 调用也应该为 true)、非空引用与 `null` 应该返回 `false`
* 对于引用变量来说，比较的是地址
* 重写 `equals()` 也需要重写 `hashCode()` 方法
```java
@Override
public boolean equals(Object obj) {
    //考虑到传入的是自己的情况
    if (this == obj) {
        return true;
    }
    if (null != obj  && obj instanceOf Student) {
        Student stu = (Student) obj
        return this.name.equals(stu.name);
    }
}
```

## `hashCode()`方法
### 特点
* 在 Java 应用的一次调用过程中，对同一个对象的 `hahsCode` 进行多次调用，应该返回同样的值。前提是对象信息没有变化。
* 对于两个对象来说，如果 使用 equals 方法返回 true，那么两个对象的 hashCode 一定是相同的。
* 对于两个对象来说，如果使用 equals方法返回 flase，那么不要求两个对象的hashCode一定不同；但是如果不同，可以提高 HashMap 的性能
* 对于集合来说，先比较已经存储在集合中的元素的 `hashCode` 是否与要加入的 `hashCode`相等， 如果不相等，直接加入，如果相等还要比较 `equals`方法，如果相等，不加入；不相等就加入。
* String 类型的 hashCode 被重写
* **安全起见，重写 equals 方法必须重写 hashCode 方法，反之亦然。**

## `toString()`方法
### 方法内部
* `getClass().getName() + '@' + Integer.toHexString(hashCode)`
* 
## `wait()` `notify()` `notifyAll()`
### 特点：
* 三个方法都是`final`的，不可更改，只能被继承，不能被重写
* 一定是成对出现的
* 要求调用时已经获得了对象的锁，因此要求放在`synchronize`中执行
* 执行了`wait`就会释放掉对象的锁
* `sleep`不会释放掉锁

## `clone()`方法
### 深拷贝和浅拷贝 

* 浅拷贝：被复制的对象的所有变量都含有与原来的对象相同的**值**，而所有的对其对象的引用**仍指向原来的对象**。换言之，浅拷贝仅仅复制所考虑的对象，而不是复制他所引用的对象。
* 深拷贝：被复制的对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。**那些引用其他对象的变量将指向被复制过的新对象，而不是那些原有的被引用的变量**。换言之，深复制就是把要复制的对象所引用的对象都复制了一遍。
* `clone()`方法满足：
    * `x.clone() != x` **克隆对象与原对象不是一个**
    * 对任何的对象 x 都有  `x.clone().getClass() == x.getClass()`
    * 重写 `equals()`方法后，`x.clone.equals(x) == true`

* 使用步骤
    * 为了获取对象的拷贝，可以利用`Object`的`clone()`方法
    * 在派生类中覆盖基类的`clone`方法，并声明为`public`
    * 在派生类的`clone`方法中，调用`super.clone()`
    * **在派生类中实现`cloneable`接口**

* 为什么一定要调用`super.clone()`
    * 在运行期，`Object`的`clone`识别出你要复制的是哪一个对象，然后为此对象分配空间，并进行对象的复制、将原始对象的内容一一复制到新对象的存储空间
    
    * 继承自 `Object` 类的`clone`方法是潜复制


* 浅复制时，可以发现，如果修改了复制出来的对象的**属性**，那么就会生成一个新的对象，而不是修改原来执行对象的值。(非引用对象)
* 深复制，让被复制的对象的引用也维护一个`clone`方法，然后在复制的对象内重新`clone`引用。

* 浅复制：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。

* 深复制：被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。